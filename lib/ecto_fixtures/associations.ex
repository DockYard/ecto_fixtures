defmodule EctoFixtures.Associations do
  alias EctoFixtures.{Dag, Dag.Vertex, PrimaryKey}

  def process(row_name, graph) do
    %Vertex{value: %{schema: schema}} = Dag.get_vertex(graph, row_name)

    Enum.reduce schema.__schema__(:associations), graph, fn(association_name, graph) ->
      if Dag.get_in(graph, row_name, [:columns, association_name]) do
        case schema.__schema__(:association, association_name) do
          %Ecto.Association.Has{} = association ->
            has_association(graph, row_name, association)
          %Ecto.Association.HasThrough{} = association ->
            has_through_association(graph, row_name, association)
          %Ecto.Association.BelongsTo{} = association ->
            belongs_to_association(graph, row_name, association)
        end
      else
        graph
      end
    end
  end

  defp has_association(graph, row_name, %{cardinality: :one} = association) do
    association_names =
      graph
      |> Dag.get_in(row_name, [:columns, association.field])
      |> List.wrap()
    
    graph
    |> Dag.put_in(row_name, [:columns, association.field], association_names)
    |> has_association(row_name, struct(association, %{cardinality: :many}))
  end

  defp has_association(graph, row_name, %{cardinality: :many} = association) do
    %{field: field, owner_key: owner_key, related_key: related_key} = association
    Enum.reduce(Dag.get_in(graph, row_name, [:columns, field]), graph, fn(association_row_name, graph) ->
      owner_key_value = Dag.get_in(graph, row_name, [:columns, owner_key])
      graph
      |> Dag.put_in(association_row_name, [:columns, related_key], owner_key_value)
      |> Dag.add_edge(row_name, association_row_name)
    end)
    |> Dag.delete_in(row_name, [:columns, field])
  end

  defp has_through_association(graph, row_name, %{cardinality: :one} = association) do
    association_names =
      graph
      |> Dag.get_in(row_name, [:columns, association.field])
      |> List.wrap()

    graph
    |> Dag.put_in(row_name, [:columns, association.field], association_names)
    |> has_through_association(row_name, struct(association, %{cardinality: :many}))
  end

  defp has_through_association(graph, row_name, %{cardinality: :many} = association) do
    %{owner: owner, field: field, through: [through_association_name, inverse_association_name]} = association

    through_association = owner.__schema__(:association, through_association_name)
    %{owner_key: through_owner_key, related_key: through_related_key, related: through_related} = through_association

    inverse_association = through_related.__schema__(:association, inverse_association_name)
    %{owner_key: inverse_owner_key, related_key: inverse_related_key} = inverse_association

    Enum.reduce(Dag.get_in(graph, row_name, [:columns, field]), graph, fn(inverse_association_row_name, graph) ->
      through_related_key_value = Dag.get_in(graph, row_name, [:columns, through_owner_key])
      inverse_owner_key_value = Dag.get_in(graph, inverse_association_row_name, [:columns, inverse_related_key])

      through_association_row_name =
        ["#{row_name}-#{through_related_key_value}", "#{inverse_association_row_name}-#{inverse_owner_key_value}"]
        |> Enum.sort()
        |> List.insert_at(-1, through_association_name)
        |> Enum.join("--")
        |> String.to_atom()

      graph = case Map.has_key?(graph.vertices, through_association_row_name) do
        true -> graph
        false ->
          through_row_attributes = %{
            schema: through_related,
            repos: Dag.get_in(graph, row_name, [:repos]),
            mod: :__AutoGenerated__,
            columns: %{
              through_related_key => through_related_key_value,
              inverse_owner_key => inverse_owner_key_value
            }
          }

          through_row_attributes = PrimaryKey.process(through_row_attributes, through_association_row_name)
          Dag.add_vertex(graph, through_association_row_name, through_row_attributes)
      end

      graph
      |> Dag.add_edge(row_name, through_association_row_name)
      |> Dag.add_edge(inverse_association_row_name, through_association_row_name)
    end)
    |> Dag.delete_in(row_name, [:columns, field])
  end

  defp belongs_to_association(graph, row_name, association) do
    %{field: field, owner_key: owner_key, related_key: related_key} = association
    association_row_name = Dag.get_in(graph, row_name, [:columns, field])
    related_key_value = Dag.get_in(graph, association_row_name, [:columns, related_key])

    graph
    |> Dag.put_in(row_name, [:columns, owner_key], related_key_value)
    |> Dag.delete_in(row_name, [:columns, field])
    |> Dag.add_edge(association_row_name, row_name)
  end
end