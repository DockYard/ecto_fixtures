defmodule EctoFixtures.Conditioners.Associations do
  import EctoFixtures.Conditioners.PrimaryKey, only: [generate_key_value: 3]

  def process(acc, row_name) do
    schema = get_in(acc, [row_name, :schema])

    Enum.reduce schema.__schema__(:associations), acc, fn(association_name, acc) ->
      if get_in(acc, [row_name, :columns, association_name]) do
        case schema.__schema__(:association, association_name) do
          %Ecto.Association.Has{} = association ->
            has_association(acc, row_name, association)
          %Ecto.Association.HasThrough{} = association ->
            has_through_association(acc, row_name, association)
          %Ecto.Association.BelongsTo{} = association ->
            belongs_to_association(acc, row_name, association)
        end
      else
        acc
      end
    end
  end

  defp has_association(acc, row_name, %{cardinality: :one} = association) do
    acc = put_in(acc, [row_name, :columns, association.field], get_in(acc, [row_name, :columns, association.field]) |> List.wrap)
    has_association(acc, row_name, struct(association, %{cardinality: :many}))
  end

  defp has_association(acc, row_name, %{cardinality: :many} = association) do
    %{field: field, owner_key: owner_key, related_key: related_key} = association
    Enum.reduce(get_in(acc, [row_name, :columns, field]), acc, fn(association_row_name, acc) ->
      acc =
        acc
        |> load_association(association_row_name)
        |> generate_key_value(row_name, owner_key)
      owner_key_value = get_in(acc, [row_name, :columns, owner_key])
      put_in(acc, [association_row_name, :columns, related_key], owner_key_value)
      |> EctoFixtures.Dag.add_vertex(association_row_name)
      |> EctoFixtures.Dag.add_edge(row_name, association_row_name)
    end)
    |> delete_in([row_name, :columns, field])
  end

  defp has_through_association(acc, row_name, %{cardinality: :one} = association) do
    acc = put_in(acc, [row_name, :columns, association.field], get_in(acc, [row_name, :columns, association.field]) |> List.wrap)
    has_through_association(acc, row_name, struct(association, %{cardinality: :many}))
  end

  defp has_through_association(acc, row_name, %{cardinality: :many} = association) do
    %{owner: owner, field: field, through: [through_association_name, inverse_association_name]} = association

    through_association = owner.__schema__(:association, through_association_name)
    %{owner_key: through_owner_key, related_key: through_related_key, related: through_related} = through_association

    inverse_association = through_related.__schema__(:association, inverse_association_name)
    %{owner_key: inverse_owner_key, related_key: inverse_related_key} = inverse_association

    Enum.reduce(get_in(acc, [row_name, :columns, field]), acc, fn(inverse_association_row_name, acc) ->
      acc =
        acc
        |> load_association(inverse_association_row_name)
        |> generate_key_value(inverse_association_row_name, inverse_related_key)

      through_related_key_value = get_in(acc, [row_name, :columns, through_owner_key])
      inverse_owner_key_value = get_in(acc, [inverse_association_row_name, :columns, inverse_related_key])

      through_association_row_name =
        ["#{row_name}-#{through_related_key_value}", "#{inverse_association_row_name}-#{inverse_owner_key_value}"]
        |> Enum.sort()
        |> List.insert_at(-1, through_association_name)
        |> Enum.join("--")
        |> String.to_atom()

      acc = case Map.has_key?(acc, through_association_name) do
        true -> acc
        false ->
          through_row_data = %{
            schema: through_related,
            repos: get_in(acc, [row_name, :repos]),
            mod: :__AutoGenerated__,
            columns: %{
              through_related_key => through_related_key_value,
              inverse_owner_key => inverse_owner_key_value
            }
          }

          [through_primary_key] = through_related.__schema__(:primary_key)

          Map.put(acc, through_association_row_name, through_row_data)
          |> EctoFixtures.Conditioners.PrimaryKey.generate_key_value(through_association_row_name, through_primary_key)
      end

      acc
      |> EctoFixtures.Dag.add_vertex(inverse_association_row_name)
      |> EctoFixtures.Dag.add_vertex(through_association_row_name)
      |> EctoFixtures.Dag.add_edge(row_name, through_association_row_name)
      |> EctoFixtures.Dag.add_edge(inverse_association_row_name, through_association_row_name)
    end)
    |> delete_in([row_name, :columns, field])
  end

  defp belongs_to_association(acc, row_name, association) do
    %{field: field, owner_key: owner_key, related_key: related_key} = association
    association_row_name = get_in(acc, [row_name, :columns, field])
    acc =
      acc
      |> load_association(association_row_name)
      |> generate_key_value(association_row_name, related_key)

    related_key_value = get_in(acc, [association_row_name, :columns, related_key])

    acc
    |> put_in([row_name, :columns, owner_key], related_key_value)
    |> delete_in([row_name, :columns, field])
    |> EctoFixtures.Dag.add_vertex(association_row_name)
    |> EctoFixtures.Dag.add_edge(association_row_name, row_name)
  end

  defp load_association(acc, association_row_name) do
    EctoFixtures.Reducer.process(acc, [[association_row_name]])
  end

  defp delete_in(acc, path) do
    {path, [target]} = Enum.split(path, length(path) - 1)
    put_in(acc, path, Map.delete(get_in(acc, path), target))
  end
end
